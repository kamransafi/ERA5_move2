#' @title Create Vegetation Indices Data Requests
#' @description Generates a list of vegetation indices data request parameters for the CDS API
#'              based on the provided request table.
#'
#' @param reqTable Request table generated by sentinel_create_request_table()
#' @param indices Character vector. Vegetation indices to download (default: c("NDVI", "EVI", "LAI"))
#' @param resolution Character. Spatial resolution (default: "10m")
#' @param processing_level Character. Processing level (default: "L2A")
#'
#' @return List of CDS API request parameters for each row in the request table
sentinel_request_vegetation_indices <- function(reqTable, 
                                                indices = c("NDVI", "EVI", "LAI"),
                                                resolution = "10m",
                                                processing_level = "L2A") {
  
  reqList <- lapply(seq_len(nrow(reqTable)), function(i) {
    filename <- paste0("VegIndices_", processing_level, "_", resolution, "_", 
                       rownames(reqTable[i,]), ".zip")
    
    # Split day values for the request format
    days <- sort(unlist(strsplit(reqTable$days[i], " ")))
    
    # Extract area values from bbox
    area_values <- as.numeric(unlist(strsplit(unlist(reqTable$bbox[i]), "/")))
    area_string <- c(area_values[1], area_values[2], area_values[3], area_values[4])
    
    # Create the request list
    list(
      dataset_short_name = "satellite-vegetation-indices",
      product_type = "sentinel-2-vegetation-indices",
      variable = indices,
      resolution = resolution,
      processing_level = processing_level,
      year = reqTable$year[i],
      month = reqTable$month[i],
      day = days,
      area = area_string,
      format = "zip",
      cloud_cover = reqTable$cloud_coverage,
      target = filename
    )
  })
  
  return(reqList)
}


#' @title Extract Data from Vegetation Indices Products
#' @description Extracts vegetation indices from downloaded zip files at tracking locations
#'
#' @param track A move2 object or data.frame with coordinates and timestamps
#' @param indices_zip_file Character. Path to downloaded vegetation indices zip file
#' @param indices Character vector. Indices to extract (default: c("NDVI", "EVI", "LAI"))
#'
#' @return Data frame with extracted values for each tracking location on the given date
sentinel_extract_vegetation_indices <- function(track, indices_zip_file, 
                                                indices = c("NDVI", "EVI", "LAI")) {
  # Extract the date from the file name
  indices_date <- ymd(as.numeric(strsplit(basename(indices_zip_file), "_")[[1]][4] %>% 
                                   substr(1, 8)))
  
  # Unzip the file to a temporary directory
  temp_dir <- file.path(tempdir(), basename(indices_zip_file))
  unzip(indices_zip_file, exdir = temp_dir)
  
  # Load the raster data for specified indices
  raster_files <- list.files(temp_dir, 
                             pattern = paste0(paste(indices, collapse = "|"), "\\.(tif|nc)$"), 
                             recursive = TRUE, full.names = TRUE)
  
  if(length(raster_files) == 0) {
    stop("No matching index files found in the archive")
  }
  
  # Load all indices as a raster stack
  indices_raster <- rast(raster_files)
  
  # Extract coordinates from track for the given date
  if(is(track, "move2")) {
    track_subset <- track[ymd(paste(year(track$timestamp), 
                                    sprintf("%02d", month(track$timestamp)), 
                                    sprintf("%02d", day(track$timestamp)))) == indices_date, ]
    coords <- as.matrix(st_coordinates(track_subset))
    event_id <- track_subset$event_id
    times <- mt_time(track_subset)
  } else if(is(track, "data.frame")) {
    track_subset <- track[ymd(paste(year(track$timestamp), 
                                    sprintf("%02d", month(track$timestamp)), 
                                    sprintf("%02d", day(track$timestamp)))) == indices_date, ]
    coords <- track_subset[, c("longitude", "latitude")]
    event_id <- track_subset$event_id
    times <- track_subset$timestamp
  }
  
  # Extract values at track locations
  extracted_values <- terra::extract(indices_raster, coords)
  
  # Create output data frame
  result <- data.frame(
    event_id = event_id,
    timestamp = times,
    longitude = coords[,1],
    latitude = coords[,2],
    extracted_values
  )
  
  # Clean up temporary directory
  unlink(temp_dir, recursive = TRUE)
  
  return(result)
}


#' @title Calculate Vegetation Indices from Sentinel-2 Bands
#' @description Calculates vegetation indices using downloaded Sentinel-2 band data
#'
#' @param s2_data Data frame. Output from sentinel_extract_S2_data with required bands
#' @param indices Character vector. Indices to calculate (default: c("NDVI", "EVI", "SAVI"))
#' @param scale_factor Numeric. Scale factor to apply to raw band values (default: 0.0001)
#'
#' @return Data frame with original data plus calculated vegetation indices
#' 
#' @details Requires specific bands in s2_data:
#'   - NDVI: Red (B04) and NIR (B08)
#'   - EVI: Blue (B02), Red (B04), and NIR (B08)
#'   - SAVI: Red (B04) and NIR (B08)
calculate_vegetation_indices <- function(s2_data, 
                                         indices = c("NDVI", "EVI", "SAVI"),
                                         scale_factor = 0.0001) {
  
  # Scale band values if needed
  if (scale_factor != 1) {
    band_cols <- grep("^B[0-9]{2}$", names(s2_data))
    s2_data[, band_cols] <- s2_data[, band_cols] * scale_factor
  }
  
  result <- s2_data
  
  # Calculate NDVI: (NIR - Red) / (NIR + Red)
  if ("NDVI" %in% indices && all(c("B04", "B08") %in% names(s2_data))) {
    result$NDVI <- (s2_data$B08 - s2_data$B04) / (s2_data$B08 + s2_data$B04)
  }
  
  # Calculate EVI: 2.5 * ((NIR - Red) / (NIR + 6*Red - 7.5*Blue + 1))
  if ("EVI" %in% indices && all(c("B02", "B04", "B08") %in% names(s2_data))) {
    result$EVI <- 2.5 * ((s2_data$B08 - s2_data$B04) / 
                           (s2_data$B08 + 6*s2_data$B04 - 7.5*s2_data$B02 + 1))
  }
  
  # Calculate SAVI: ((NIR - Red) / (NIR + Red + L)) * (1 + L) where L=0.5
  if ("SAVI" %in% indices && all(c("B04", "B08") %in% names(s2_data))) {
    L <- 0.5 # Soil brightness correction factor
    result$SAVI <- ((s2_data$B08 - s2_data$B04) / (s2_data$B08 + s2_data$B04 + L)) * (1 + L)
  }
  
  return(result)
}


#' @title Create Land Cover Data Requests
#' @description Generates requests for land cover data from CDS
#'
#' @param reqTable Request table generated by sentinel_create_request_table()
#' @param product Character. Land cover product (default: "global-land-cover")
#' @param resolution Character. Spatial resolution (default: "100m")
#' @param year Numeric. Year for land cover data (default: current year - 1)
#'
#' @return List of CDS API request parameters for each row in the request table
sentinel_request_land_cover <- function(reqTable, 
                                        product = "global-land-cover",
                                        resolution = "100m",
                                        year = NULL) {
  
  # Default to previous year if not specified
  if (is.null(year)) {
    year <- as.numeric(format(Sys.Date(), "%Y")) - 1
  }
  
  reqList <- lapply(seq_len(nrow(reqTable)), function(i) {
    filename <- paste0("LandCover_", product, "_", year, "_", resolution, "_", 
                       rownames(reqTable[i,]), ".zip")
    
    # Extract area values from bbox
    area_values <- as.numeric(unlist(strsplit(unlist(reqTable$bbox[i]), "/")))
    area_string <- c(area_values[1], area_values[2], area_values[3], area_values[4])
    
    # Create the request list
    list(
      dataset_short_name = "satellite-land-cover",
      product_type = product,
      variable = "all",
      year = year,
      version = "latest",
      resolution = resolution,
      area = area_string,
      format = "zip",
      target = filename
    )
  })
  
  return(reqList)
}


#' @title Create Environmental Variables Requests for Species Distribution Modeling
#' @description Generates requests for environmental variables important for SDM
#'
#' @param reqTable Request table generated by sentinel_create_request_table()
#' @param variables Character vector. Variables to download
#' @param resolution Character. Spatial resolution (default: varies by dataset)
#'
#' @return List of CDS API request parameters for each row in the request table
sentinel_request_sdm_variables <- function(reqTable, 
                                           variables = c("soil_moisture", "land_surface_temperature", 
                                                         "precipitation", "elevation", "slope"),
                                           resolution = "best") {
  
  # Dictionary mapping variables to their CDS dataset and product details
  var_dict <- list(
    soil_moisture = list(
      dataset = "satellite-soil-moisture",
      product_type = "soil-moisture-daily",
      resolution = ifelse(resolution == "best", "1km", resolution)
    ),
    land_surface_temperature = list(
      dataset = "satellite-land-surface-temperature",
      product_type = "lst-daily",
      resolution = ifelse(resolution == "best", "1km", resolution)
    ),
    precipitation = list(
      dataset = "satellite-precipitation",
      product_type = "precipitation-daily",
      resolution = ifelse(resolution == "best", "5km", resolution)
    ),
    elevation = list(
      dataset = "digital-elevation-model",
      product_type = "global-dem",
      resolution = ifelse(resolution == "best", "30m", resolution)
    )
  )
  
  # For each variable, create requests
  all_requests <- list()
  
  for (var in variables) {
    if (!var %in% names(var_dict)) {
      warning(paste("Variable", var, "not found in dictionary, skipping"))
      next
    }
    
    var_info <- var_dict[[var]]
    
    var_requests <- lapply(seq_len(nrow(reqTable)), function(i) {
      filename <- paste0(var, "_", var_info$resolution, "_", rownames(reqTable[i,]), ".zip")
      
      # Split day values for the request format
      days <- sort(unlist(strsplit(reqTable$days[i], " ")))
      
      # Extract area values from bbox
      area_values <- as.numeric(unlist(strsplit(unlist(reqTable$bbox[i]), "/")))
      area_string <- c(area_values[1], area_values[2], area_values[3], area_values[4])
      
      # Create the request list - for static variables like elevation, omit temporal parameters
      if (var %in% c("elevation", "slope")) {
        list(
          dataset_short_name = var_info$dataset,
          product_type = var_info$product_type,
          variable = var,
          resolution = var_info$resolution,
          area = area_string,
          format = "zip",
          target = filename
        )
      } else {
        list(
          dataset_short_name = var_info$dataset,
          product_type = var_info$product_type,
          variable = var,
          resolution = var_info$resolution,
          year = reqTable$year[i],
          month = reqTable$month[i],
          day = days,
          area = area_string,
          format = "zip",
          target = filename
        )
      }
    })
    
    all_requests <- c(all_requests, var_requests)
  }
  
  return(all_requests)
}


# Load spatial data for your species
species_data <- st_read("species_occurrences.shp")
species_sf <- st_as_sf(species_data, coords = c("longitude", "latitude"), crs = 4326)

# Add timestamp column if not present
if (!"timestamp" %in% names(species_sf)) {
  species_sf$timestamp <- as.POSIXct(species_sf$observation_date)
}

# 1. Create request table
req_table <- sentinel_create_request_table(
  track = species_sf,
  timeCol = "timestamp",
  timeUnit = "month",
  area = "byTimeUnit",
  cloud_coverage = 10,
  area_ext = 0.05
)

# 2. Request vegetation indices
veg_options <- list(
  indices = c("NDVI", "EVI", "LAI", "FAPAR"),
  resolution = "10m"
)

veg_requests <- sentinel_create_request_list(
  reqTable = req_table,
  satellite = "vegetation-indices",  # New satellite type
  product_options = veg_options
)

# 3. Request environmental variables for SDM
env_requests <- sentinel_request_sdm_variables(
  reqTable = req_table,
  variables = c("soil_moisture", "land_surface_temperature", "precipitation", "elevation"),
  resolution = "best"
)

# 4. Submit all requests
sentinel_send_requests(veg_requests, localPath = "data/vegetation", batch_size = 5)
sentinel_send_requests(env_requests, localPath = "data/environment", batch_size = 5)

# 5. Process and combine the data
veg_files <- list.files("data/vegetation", pattern = "\\.zip$", full.names = TRUE)
env_files <- list.files("data/environment", pattern = "\\.zip$", full.names = TRUE)

# Extract vegetation data
veg_data <- lapply(veg_files, function(file) {
  sentinel_extract_vegetation_indices(species_sf, file)
})

# Extract environmental data (example for elevation)
elev_file <- env_files[grep("elevation", env_files)]
if (length(elev_file) > 0) {
  elev_data <- extract_raster_data(species_sf, elev_file[1])
}

# Combine all data for modeling
sdm_data <- Reduce(function(x, y) merge(x, y, by = c("event_id", "timestamp")), veg_data)
if (exists("elev_data")) {
  sdm_data <- merge(sdm_data, elev_data, by = c("event_id", "timestamp"))
}
